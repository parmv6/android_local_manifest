From dd3a3c3357d337b18be1541333c3eab551235967 Mon Sep 17 00:00:00 2001
From: Kyrylo Mikos <kiril.mik.os@gmail.com>
Date: Thu, 25 Jul 2013 18:58:10 +0300
Subject: [PATCH] DeskClock: Add feature to play random song as an alarm.

Change-Id: Ia3d2f28d71456ba16aac4474db15cddacada9410
---
 res/values/cm_arrays.xml                          |   5 +
 res/values/cm_strings.xml                         |   7 +
 src/com/android/deskclock/AlarmClockFragment.java |  38 ++-
 src/com/android/deskclock/MultiPlayer.java        | 320 ++++++++++++++++++++++
 src/com/android/deskclock/alarms/AlarmKlaxon.java |   9 +-
 5 files changed, 371 insertions(+), 8 deletions(-)
 create mode 100755 src/com/android/deskclock/MultiPlayer.java

diff --git a/res/values/cm_arrays.xml b/res/values/cm_arrays.xml
index 2da1cc3..753a5b4 100644
--- a/res/values/cm_arrays.xml
+++ b/res/values/cm_arrays.xml
@@ -29,4 +29,9 @@
       <item>2</item>
       <item>0</item>
     </string-array>
+
+    <string-array name="ringtone_picker_entries" translatable="false">
+        <item>@string/alarm_type_ringtone</item>
+        <item>@string/alarm_type_random</item>
+    </string-array>
 </resources>
diff --git a/res/values/cm_strings.xml b/res/values/cm_strings.xml
index 8259eb1..112608c 100644
--- a/res/values/cm_strings.xml
+++ b/res/values/cm_strings.xml
@@ -72,4 +72,11 @@
     <string name="action_summary_snooze">snooze alarm</string>
     <string name="action_summary_dismiss">dismiss alarm</string>
     <string name="action_summary_do_nothing">do nothing</string>
+
+    <!-- Alarm picker dialog title -->
+    <string name="alarm_picker_title">Choose alarm type</string>
+
+    <!-- Alarm types -->
+    <string name="alarm_type_ringtone">Ringtone</string>
+    <string name="alarm_type_random">Randomly</string>
 </resources>
diff --git a/src/com/android/deskclock/AlarmClockFragment.java b/src/com/android/deskclock/AlarmClockFragment.java
index 06711dd..fe619c4 100644
--- a/src/com/android/deskclock/AlarmClockFragment.java
+++ b/src/com/android/deskclock/AlarmClockFragment.java
@@ -21,6 +21,7 @@ import android.animation.Animator.AnimatorListener;
 import android.animation.AnimatorInflater;
 import android.animation.ValueAnimator;
 import android.app.Activity;
+import android.app.AlertDialog;
 import android.app.Fragment;
 import android.app.FragmentTransaction;
 import android.app.LoaderManager;
@@ -28,6 +29,7 @@ import android.app.Profile;
 import android.app.ProfileManager;
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.Loader;
 import android.content.res.Configuration;
@@ -673,7 +675,31 @@ public class AlarmClockFragment extends DeskClockFragment implements
         mAdapter.swapCursor(null);
     }
 
-    private void launchRingTonePicker(Alarm alarm) {
+    private void launchRingTonePicker(final Alarm alarm) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+        builder.setTitle(R.string.alarm_picker_title).setItems(
+                R.array.ringtone_picker_entries,
+
+                new DialogInterface.OnClickListener() {
+
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        switch (which) {
+                            case 0:
+                                launchSingleRingTonePicker(alarm);
+                                break;
+                            case 1:
+                                alarm.alert = MultiPlayer.RANDOM_URI;
+                                asyncUpdateAlarm(alarm, false);
+                                break;
+                        }
+                    }
+                });
+        AlertDialog d = builder.create();
+        d.show();
+    }
+
+    private void launchSingleRingTonePicker(Alarm alarm) {
         mSelectedAlarm = alarm;
         Uri oldRingtone = Alarm.NO_RINGTONE_URI.equals(alarm.alert) ? null : alarm.alert;
         final Intent intent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);
@@ -1502,9 +1528,13 @@ public class AlarmClockFragment extends DeskClockFragment implements
             // Try the cache first
             String title = mRingtoneTitleCache.getString(uri.toString());
             if (title == null) {
-                // This is slow because a media player is created during Ringtone object creation.
-                Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);
-                title = ringTone.getTitle(mContext);
+                if (uri.equals(MultiPlayer.RANDOM_URI)) {
+                    title = mContext.getResources().getString(R.string.alarm_type_random);
+                } else {
+                    // This is slow because a media player is created during Ringtone object creation.
+                    Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);
+                    title = ringTone.getTitle(mContext);
+                }
                 if (title != null) {
                     mRingtoneTitleCache.putString(uri.toString(), title);
                 }
diff --git a/src/com/android/deskclock/MultiPlayer.java b/src/com/android/deskclock/MultiPlayer.java
new file mode 100755
index 0000000..08813b8
--- /dev/null
+++ b/src/com/android/deskclock/MultiPlayer.java
@@ -0,0 +1,320 @@
+package com.android.deskclock;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+
+import android.content.ContentUris;
+import android.content.Context;
+import android.database.Cursor;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.media.MediaPlayer.OnErrorListener;
+import android.net.Uri;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio;
+
+public class MultiPlayer implements MediaPlayer.OnCompletionListener {
+
+    public static final Uri RANDOM_URI = Uri.parse("random");
+
+    private MediaPlayer mCurrentMediaPlayer = new MediaPlayer();
+    private MediaPlayer mNextMediaPlayer;
+
+    private boolean mIsInitialized = false;
+
+    private Context mContext;
+
+    private boolean mSingle;
+
+    private OnErrorListener mErrorListener;
+    private int mAudioStreamType = AudioManager.STREAM_ALARM;
+    private boolean mLooping;
+    private boolean mIsExternal;
+    private boolean mRandom;
+
+    private Cursor mCursor;
+
+    private int mColumnIndex;
+    private float mLeftVolume = -1;
+    private float mRightVolume = -1;
+
+    /**
+     * Constructor of <code>MultiPlayer</code>
+     */
+    public MultiPlayer(Context context) {
+        mContext = context;
+    }
+
+    /**
+     * @param uri The Uri you want to play
+     */
+    public void setDataSource(Context context, final Uri uri) {
+        handleSetDataSourceUri(uri);
+        mIsInitialized = setDataSourceImpl(mCurrentMediaPlayer, getNextUri());
+        if (mIsInitialized) {
+            if (mSingle) {
+                setNextDataSource(null);
+            } else {
+                setNextDataSource(getNextUri());
+            }
+        }
+    }
+
+    /**
+     * Sets the data source (FileDescriptor) to use. It is the caller's responsibility
+     * to close the file descriptor. It is safe to do so as soon as this call returns.
+     *
+     * @param fd the FileDescriptor for the file you want to play
+     * @throws IllegalStateException if it is called in an invalid state
+     */
+    public void setDataSource(FileDescriptor fd, long offset, long length) {
+        mIsInitialized = setDataSourceImpl(mCurrentMediaPlayer, fd, offset, length);
+        if (mIsInitialized) {
+            mSingle = true;
+            setNextDataSource(null);
+        }
+    }
+
+    /**
+     * @param player The {@link MediaPlayer} to use
+     * @param uri The path of the file, or the http/rtsp URL of the stream
+     *            you want to play
+     * @return True if the <code>player</code> has been prepared and is
+     *         ready to play, false otherwise
+     */
+    private boolean setDataSourceImpl(final MediaPlayer player, final Uri uri) {
+        try {
+            player.reset();
+            player.setOnPreparedListener(null);
+            player.setDataSource(mContext, uri);
+            player.setAudioStreamType(mAudioStreamType);
+            if (mLeftVolume != -1 && mRightVolume != -1) {
+                player.setVolume(mLeftVolume, mRightVolume);
+            }
+            mCurrentMediaPlayer.setLooping(mLooping);
+            player.prepare();
+        } catch (final IOException todo) {
+            return false;
+        } catch (final IllegalArgumentException todo) {
+            return false;
+        }
+        player.setOnCompletionListener(this);
+        player.setOnErrorListener(mErrorListener);
+        return true;
+    }
+
+    private boolean setDataSourceImpl(
+            final MediaPlayer player, FileDescriptor fd, long offset, long length) {
+        try {
+            player.reset();
+            player.setOnPreparedListener(null);
+            player.setDataSource(fd, offset, length);
+            player.setAudioStreamType(mAudioStreamType);
+            if (mLeftVolume != -1 && mRightVolume != -1) {
+                player.setVolume(mLeftVolume, mRightVolume);
+            }
+            player.setLooping(mLooping);
+            player.prepare();
+        } catch (final IOException todo) {
+            return false;
+        } catch (final IllegalArgumentException todo) {
+            return false;
+        }
+        player.setOnCompletionListener(this);
+        player.setOnErrorListener(mErrorListener);
+        return true;
+    }
+
+    /**
+     * Set the MediaPlayer to start when this MediaPlayer finishes playback.
+     *
+     * @param uri The path of the file, or the http/rtsp URL of the stream
+     *            you want to play
+     */
+    public void setNextDataSource(final Uri uri) {
+        mCurrentMediaPlayer.setNextMediaPlayer(null);
+        if (mNextMediaPlayer != null) {
+            mNextMediaPlayer.release();
+            mNextMediaPlayer = null;
+        }
+        if (uri == null) {
+            return;
+        }
+        mNextMediaPlayer = new MediaPlayer();
+        mNextMediaPlayer.setAudioSessionId(getAudioSessionId());
+        if (setDataSourceImpl(mNextMediaPlayer, uri)) {
+            mCurrentMediaPlayer.setNextMediaPlayer(mNextMediaPlayer);
+        } else {
+            if (mNextMediaPlayer != null) {
+                mNextMediaPlayer.release();
+                mNextMediaPlayer = null;
+            }
+        }
+    }
+
+    /**
+     * Starts or resumes playback.
+     */
+    public void start() {
+        mCurrentMediaPlayer.start();
+    }
+
+    /**
+     * Resets the MediaPlayer to its uninitialized state.
+     */
+    public void stop() {
+        mCurrentMediaPlayer.reset();
+        mIsInitialized = false;
+    }
+
+    /**
+     * Releases resources associated with this MediaPlayer object.
+     */
+    public void release() {
+        stop();
+        mCurrentMediaPlayer.release();
+
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+    }
+
+    public void reset() {
+    }
+
+    /**
+     * Sets the volume on this player.
+     *
+     * @param leftVol Left and right volume scalar
+     */
+    public void setVolume(final float leftVol, final float rightVol) {
+        mLeftVolume = leftVol;
+        mRightVolume = rightVol;
+        mCurrentMediaPlayer.setVolume(mLeftVolume, mRightVolume);
+        if (mNextMediaPlayer != null) {
+            mNextMediaPlayer.setVolume(mLeftVolume, mRightVolume);
+        }
+    }
+
+    /**
+     * Returns the audio session ID.
+     *
+     * @return The current audio session ID.
+     */
+    public int getAudioSessionId() {
+        return mCurrentMediaPlayer.getAudioSessionId();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCompletion(final MediaPlayer mp) {
+        if (mLooping) {
+            // do not control sequence if we are looping
+            return;
+        }
+        if (mp == mCurrentMediaPlayer && mNextMediaPlayer != null) {
+            mCurrentMediaPlayer.release();
+            mCurrentMediaPlayer = mNextMediaPlayer;
+            mNextMediaPlayer = null;
+        }
+
+        setNextDataSource(getNextUri());
+    }
+
+    private Uri getNextUri() {
+        if (mRandom) {
+            Cursor c = mContext.getContentResolver().query(
+                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                    null, null, null, "RANDOM() LIMIT 1");
+            if (c.moveToFirst()) {
+                long id = c.getLong(c.getColumnIndex(MediaStore.Audio.Media._ID));
+                return ContentUris.withAppendedId(Audio.Media.EXTERNAL_CONTENT_URI, id);
+            }
+            return null;
+        }
+        if (mCursor == null) {
+            Log.e("MultiPlayer: mCursor = null");
+            return null;
+        }
+
+        long id = mCursor.getLong(mColumnIndex);
+        if (!mCursor.moveToNext()) {
+            // Cycle through the playlist
+            mCursor.moveToFirst();
+        }
+        if(mIsExternal) {
+            return ContentUris.withAppendedId(Audio.Media.EXTERNAL_CONTENT_URI, id);
+        } else {
+            return ContentUris.withAppendedId(Audio.Media.INTERNAL_CONTENT_URI, id);
+        }
+    }
+
+    private void handleSetDataSourceUri(Uri uri) {
+        mSingle = false;
+        if (uri.equals(RANDOM_URI)) {
+            mRandom = true;
+            return;
+        }
+
+        String columnName = null;
+        final String rawUri = uri.toString();
+        if (rawUri.startsWith(Audio.Media.EXTERNAL_CONTENT_URI.toString())
+                || rawUri.startsWith(Audio.Media.INTERNAL_CONTENT_URI.toString())) {
+            columnName = Audio.Media._ID;
+        } else if (rawUri.startsWith(Audio.Playlists.EXTERNAL_CONTENT_URI.toString())
+                || rawUri.startsWith(Audio.Playlists.INTERNAL_CONTENT_URI.toString())) {
+            long playlist_id = Long.parseLong(uri.getLastPathSegment());
+            uri = Audio.Playlists.Members.getContentUri("external", playlist_id);
+            columnName = Audio.Playlists.Members.AUDIO_ID;
+        } else {
+            Log.e("MultiPlayer: unknown uri: "+uri.toString());
+        }
+        mIsExternal = rawUri.contains("external");
+        mCursor = mContext.getContentResolver().query(uri, null, null, null, null);
+        if (mCursor == null) {
+            Log.e("MultiPlayr: Query failed, cursor = null");
+            return;
+        }
+        mColumnIndex = mCursor.getColumnIndex(columnName);
+        if (mCursor.getCount() == 0) {
+            Log.e("MultiPlayr: Query failed, cursor.getCout() = 0");
+            return;
+        }
+        mCursor.moveToFirst();
+
+        if (mCursor.getCount() == 1) {
+            mSingle = true;
+        }
+    }
+
+    public boolean isPlaying() {
+        return mCurrentMediaPlayer.isPlaying();
+    }
+
+    public void setOnErrorListener(MediaPlayer.OnErrorListener l) {
+        mErrorListener = l;
+    }
+
+    public void setAudioStreamType(int type) {
+        mAudioStreamType = type;
+        mCurrentMediaPlayer.setAudioStreamType(mAudioStreamType);
+        if(mNextMediaPlayer != null) {
+            mNextMediaPlayer.setAudioStreamType(mAudioStreamType);
+        }
+    }
+
+    public void setLooping(boolean looping) {
+        if (mSingle) {
+            mLooping = looping;
+        } else {
+            mLooping = false;
+        }
+        mCurrentMediaPlayer.setLooping(mLooping);
+    }
+
+    public void prepare() {
+    }
+}
diff --git a/src/com/android/deskclock/alarms/AlarmKlaxon.java b/src/com/android/deskclock/alarms/AlarmKlaxon.java
index 380c8f4..b84518a 100644
--- a/src/com/android/deskclock/alarms/AlarmKlaxon.java
+++ b/src/com/android/deskclock/alarms/AlarmKlaxon.java
@@ -28,6 +28,7 @@ import android.os.Message;
 import android.os.Vibrator;
 
 import com.android.deskclock.Log;
+import com.android.deskclock.MultiPlayer;
 import com.android.deskclock.R;
 import com.android.deskclock.provider.AlarmInstance;
 
@@ -49,7 +50,7 @@ public class AlarmKlaxon {
 
     private static boolean sStarted = false;
     private static AudioManager sAudioManager = null;
-    private static MediaPlayer sMediaPlayer = null;
+    private static MultiPlayer sMediaPlayer = null;
 
     private static int sCurrentVolume = INCREASING_VOLUME_START;
     private static int sAlarmVolumeSetting;
@@ -131,7 +132,7 @@ public class AlarmKlaxon {
             }
 
             // TODO: Reuse mMediaPlayer instead of creating a new one and/or use RingtoneManager.
-            sMediaPlayer = new MediaPlayer();
+            sMediaPlayer = new MultiPlayer(context);
             sMediaPlayer.setOnErrorListener(new OnErrorListener() {
                 @Override
                 public boolean onError(MediaPlayer mp, int what, int extra) {
@@ -177,7 +178,7 @@ public class AlarmKlaxon {
     }
 
     // Do the common stuff when starting the alarm.
-    private static void startAlarm(Context context, MediaPlayer player,
+    private static void startAlarm(Context context, MultiPlayer player,
             AlarmInstance instance) throws IOException {
         // do not play alarms if stream volume is 0 (typically because ringer mode is silent).
         if (sAudioManager.getStreamVolume(AudioManager.STREAM_ALARM) != 0) {
@@ -194,7 +195,7 @@ public class AlarmKlaxon {
         }
     }
 
-    private static void setDataSourceFromResource(Context context, MediaPlayer player, int res)
+    private static void setDataSourceFromResource(Context context, MultiPlayer player, int res)
             throws IOException {
         AssetFileDescriptor afd = context.getResources().openRawResourceFd(res);
         if (afd != null) {
-- 
1.9.0

