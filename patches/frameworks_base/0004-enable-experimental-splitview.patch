From 3f1df0c87c1f7ff25e043b86639b8fd953559407 Mon Sep 17 00:00:00 2001
From: xplodwild <xplod@ouverta.fr>
Date: Tue, 3 Sep 2013 20:55:56 +0200
Subject: [PATCH] [WIP] Multi-window

[[[ USE PS 18 IF YOU WANT TO TEST - WORK IN PROGRESS ]]]

This is a big work in progress, which currently has some bugs,
but begins to look okay.

You can already multitask a little bit, by using the
app switcher and long-pressing an icon, then select "Add to
Split View".
Last window touched gets the key focus.

Code is very ugly, I know. Don't merge it, don't use it
for now. Unless you want to make your code ugly.

Enjoy :)

PS 22: rebased

Conflicts:
	packages/SystemUI/res/values/custom_strings.xml

Change-Id: I4a03a84539fd3ac1273f0d3503fe8fafcd16be26
---
 core/java/android/app/Activity.java                | 111 ++++-
 core/java/android/app/ActivityManagerNative.java   |  41 ++
 core/java/android/app/IActivityManager.java        |   8 +
 core/java/android/content/Intent.java              |   7 +
 .../inputmethodservice/InputMethodService.java     |  23 +-
 core/java/android/view/IWindowManager.aidl         |  10 +
 packages/SystemUI/res/menu/recent_popup_menu.xml   |   1 +
 packages/SystemUI/res/values/custom_strings.xml    |   3 +
 .../android/systemui/recent/RecentsActivity.java   |   7 +
 .../android/systemui/recent/RecentsPanelView.java  | 179 +++++++
 .../android/internal/policy/impl/PhoneWindow.java  |   1 +
 .../internal/policy/impl/PhoneWindowManager.java   |   4 +
 .../android/server/am/ActivityManagerService.java  |  99 +++-
 .../java/com/android/server/am/ActivityStack.java  |  17 +-
 .../android/server/wm/WindowManagerService.java    | 554 ++++++++++++++++++++-
 15 files changed, 1057 insertions(+), 8 deletions(-)

diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java
index d6db8c2..dcdd0d0 100644
--- a/core/java/android/app/Activity.java
+++ b/core/java/android/app/Activity.java
@@ -39,6 +39,7 @@ import android.content.res.TypedArray;
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.media.AudioManager;
 import android.net.Uri;
@@ -65,6 +66,8 @@ import android.view.ActionMode;
 import android.view.ContextMenu;
 import android.view.ContextMenu.ContextMenuInfo;
 import android.view.ContextThemeWrapper;
+import android.view.Gravity;
+import android.view.IWindowManager;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -647,7 +650,7 @@ public class Activity extends ContextThemeWrapper
         Window.Callback, KeyEvent.Callback,
         OnCreateContextMenuListener, ComponentCallbacks2 {
     private static final String TAG = "Activity";
-    private static final boolean DEBUG_LIFECYCLE = false;
+    private static final boolean DEBUG_LIFECYCLE = true;
 
     /** Standard activity result: operation canceled. */
     public static final int RESULT_CANCELED    = 0;
@@ -764,6 +767,9 @@ public class Activity extends ContextThemeWrapper
     private Thread mUiThread;
     final Handler mHandler = new Handler();
 
+    private Rect mOriginalBounds;
+    private boolean mIsSplitView;
+
     /** Return the intent that started this activity. */
     public Intent getIntent() {
         return mIntent;
@@ -2455,6 +2461,14 @@ public class Activity extends ContextThemeWrapper
         if (ev.getAction() == MotionEvent.ACTION_DOWN) {
             onUserInteraction();
         }
+        if (mIsSplitView && ev.getAction() == MotionEvent.ACTION_DOWN) {
+            IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            try {
+                wm.notifyActivityTouched(mToken, false);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Cannot notify activity touched", e);
+            }
+        }
         if (getWindow().superDispatchTouchEvent(ev)) {
             return true;
         }
@@ -5186,7 +5200,7 @@ public class Activity extends ContextThemeWrapper
         attachBaseContext(context);
 
         mFragments.attachActivity(this, mContainer, null);
-        
+
         mWindow = PolicyManager.makeNewWindow(this);
         mWindow.setCallback(this);
         mWindow.getLayoutInflater().setPrivateFactory(this);
@@ -5220,6 +5234,11 @@ public class Activity extends ContextThemeWrapper
         }
         mWindowManager = mWindow.getWindowManager();
         mCurrentConfig = config;
+
+        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_SPLIT_VIEW) != 0) {
+            final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            updateSplitViewMetrics(true);
+        }
     }
 
     /** @hide */
@@ -5227,6 +5246,93 @@ public class Activity extends ContextThemeWrapper
         return mParent != null ? mParent.getActivityToken() : mToken;
     }
 
+    /** @hide */
+    public final void setSplitViewRect(int l, int t, int r, int b) {
+        final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+        /*try {
+            wm.setSplitViewRect(l,t,r,b);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Could not update split view rect", e);
+        }*/
+        updateSplitViewMetrics(false);
+    }
+
+    /** @hide */
+    public final boolean isSplitView() {
+        return mIsSplitView;
+    }
+
+    /** @hide */
+    final void updateSplitViewMetrics(boolean shouldReset) {
+        if (mParent != null) {
+            // Also update the parent activities, don't let the windows hanging
+            mParent.updateSplitViewMetrics(shouldReset);
+        }
+
+        final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+
+        try {
+            mIsSplitView = false;
+
+            if (shouldReset) {
+                wm.getSplitViewRect(getTaskId());
+            }
+
+            // Check for split view settings
+            if (wm.isTaskSplitView(getTaskId())) {
+                // This activity/task is tagged as being in split view
+                mIsSplitView = true;
+
+                wm.setTaskChildSplit(getTaskId(), mToken, true);
+
+                // Then, we apply it the position and size
+                mWindow.setGravity(Gravity.LEFT | Gravity.TOP);
+
+                WindowManager.LayoutParams params = mWindow.getAttributes();
+
+                // We save the original window size, in case we want to restore it later
+                if (mOriginalBounds == null) {
+                    mOriginalBounds = new Rect();
+                    mOriginalBounds.left = params.x;
+                    mOriginalBounds.top = params.y;
+                    mOriginalBounds.right = params.x + params.width;
+                    mOriginalBounds.bottom = params.y + params.height;
+                }
+
+                /*try {
+                    wm.setSplitViewRect(mOriginalBounds.left, mOriginalBounds.top, mOriginalBounds.right, mOriginalBounds.bottom);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Could not update split view rect", e);
+                }*/
+
+                Rect windowBounds = wm.getSplitViewRect(getTaskId());
+                mWindow.setLayout(windowBounds.right - windowBounds.left,
+                    windowBounds.bottom - windowBounds.top);
+
+                params.x = windowBounds.left;
+                params.y = windowBounds.top;
+                mWindow.setAttributes(params);
+
+                // Finally, we make the window non-modal to allow the second app to get input
+                mWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
+                mWindow.addFlags(WindowManager.LayoutParams.FLAG_SPLIT_TOUCH);
+            } else if (mOriginalBounds != null) {
+                // Restore normal window bounds
+                Log.d(TAG, "Restore original bounds from split (TaskId=" + getTaskId() + ")");
+                WindowManager.LayoutParams params = mWindow.getAttributes();
+                params.x = mOriginalBounds.left;
+                params.y = mOriginalBounds.top;
+
+                mWindow.setLayout(mOriginalBounds.right - mOriginalBounds.left,
+                    mOriginalBounds.bottom - mOriginalBounds.top);
+
+                wm.setTaskChildSplit(getTaskId(), mToken, false);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Could not perform split view actions on restart", e);
+        }
+    }
+
     final void performCreate(Bundle icicle) {
         onCreate(icicle);
         mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(
@@ -5261,6 +5367,7 @@ public class Activity extends ContextThemeWrapper
     
     final void performRestart() {
         mFragments.noteStateNotSaved();
+        updateSplitViewMetrics(false);
 
         if (mStopped) {
             mStopped = false;
diff --git a/core/java/android/app/ActivityManagerNative.java b/core/java/android/app/ActivityManagerNative.java
index 74266cc..f1afd24 100644
--- a/core/java/android/app/ActivityManagerNative.java
+++ b/core/java/android/app/ActivityManagerNative.java
@@ -683,6 +683,16 @@ public abstract class ActivityManagerNative extends Binder implements IActivityM
             return true;
         }
 
+        case GET_ACTIVITY_FOR_TASK_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            int task = data.readInt();
+            boolean onlyRoot = data.readInt() != 0;
+            IBinder res = getActivityForTask(task, onlyRoot);
+            reply.writeNoException();
+            reply.writeStrongBinder(res);
+            return true;
+        }
+
         case REPORT_THUMBNAIL_TRANSACTION: {
             data.enforceInterface(IActivityManager.descriptor);
             IBinder token = data.readStrongBinder();
@@ -2028,6 +2038,13 @@ public abstract class ActivityManagerNative extends Binder implements IActivityM
             reply.writeNoException();
             return true;
         }
+
+        case NOTIFY_SPLIT_VIEW_LAYOUT_CHANGED: {
+            data.enforceInterface(IActivityManager.descriptor);
+            notifySplitViewLayoutChanged();
+            reply.writeNoException();
+            return true;
+        }
         }
 
         return super.onTransact(code, data, reply, flags);
@@ -2816,6 +2833,20 @@ class ActivityManagerProxy implements IActivityManager
         reply.recycle();
         return res;
     }
+    public IBinder getActivityForTask(int task, boolean onlyRoot) throws RemoteException
+    {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeInt(task);
+        data.writeInt(onlyRoot ? 1 : 0);
+        mRemote.transact(GET_ACTIVITY_FOR_TASK_TRANSACTION, data, reply, 0);
+        reply.readException();
+        IBinder res = reply.readStrongBinder();
+        data.recycle();
+        reply.recycle();
+        return res;
+    }
     public void reportThumbnail(IBinder token,
                                 Bitmap thumbnail, CharSequence description) throws RemoteException
     {
@@ -4660,5 +4691,15 @@ class ActivityManagerProxy implements IActivityManager
         reply.recycle();
     }
 
+    public void notifySplitViewLayoutChanged() throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        mRemote.transact(NOTIFY_SPLIT_VIEW_LAYOUT_CHANGED, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
     private IBinder mRemote;
 }
diff --git a/core/java/android/app/IActivityManager.java b/core/java/android/app/IActivityManager.java
index 77c2ea0..57f44a5 100644
--- a/core/java/android/app/IActivityManager.java
+++ b/core/java/android/app/IActivityManager.java
@@ -125,6 +125,7 @@ public interface IActivityManager extends IInterface {
     public StackBoxInfo getStackBoxInfo(int stackBoxId) throws RemoteException;
     public void setFocusedStack(int stackId) throws RemoteException;
     public int getTaskForActivity(IBinder token, boolean onlyRoot) throws RemoteException;
+    public IBinder getActivityForTask(int task, boolean onlyRoot) throws RemoteException;
     /* oneway */
     public void reportThumbnail(IBinder token,
             Bitmap thumbnail, CharSequence description) throws RemoteException;
@@ -408,6 +409,9 @@ public interface IActivityManager extends IInterface {
 
     public void performIdleMaintenance() throws RemoteException;
 
+    /* SPLIT VIEW */
+    public void notifySplitViewLayoutChanged() throws RemoteException;
+
     /*
      * Private non-Binder interfaces
      */
@@ -694,4 +698,8 @@ public interface IActivityManager extends IInterface {
     int RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+180;
     int GET_PERSISTED_URI_PERMISSIONS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+181;
     int APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+182;
+
+    /* SPLIT VIEW */
+    int GET_ACTIVITY_FOR_TASK_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+200;
+    int NOTIFY_SPLIT_VIEW_LAYOUT_CHANGED = IBinder.FIRST_CALL_TRANSACTION+201;
 }
diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index a934276..c818324 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -3619,6 +3619,13 @@ public class Intent implements Parcelable, Cloneable {
      */
     public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;
     /**
+     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
+     * this flag will cause a newly launching task to be resized according to the split
+     * view metrics, making it running alongside another app.
+     * @hide
+     */
+    public static final int FLAG_ACTIVITY_SPLIT_VIEW = 0x00002000;
+    /**
      * If set, when sending a broadcast only registered receivers will be
      * called -- no BroadcastReceiver components will be launched.
      */
diff --git a/core/java/android/inputmethodservice/InputMethodService.java b/core/java/android/inputmethodservice/InputMethodService.java
index 79a92b9..c79895b 100644
--- a/core/java/android/inputmethodservice/InputMethodService.java
+++ b/core/java/android/inputmethodservice/InputMethodService.java
@@ -19,6 +19,7 @@ package android.inputmethodservice;
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
+import android.app.Activity;
 import android.app.ActivityManager;
 import android.app.Dialog;
 import android.content.Context;
@@ -43,6 +44,7 @@ import android.text.method.MovementMethod;
 import android.util.Log;
 import android.util.PrintWriterPrinter;
 import android.util.Printer;
+import android.view.IWindowManager;
 import android.view.KeyCharacterMap;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -915,7 +917,7 @@ public class InputMethodService extends AbstractInputMethodService {
         if (fullScreenOverride) {
             isFullscreen = false;
         } else {
-            isFullscreen = mShowInputRequested && onEvaluateFullscreenMode();
+            isFullscreen = mShowInputRequested && (onEvaluateFullscreenMode() || onEvaluateSplitView());
         }
         boolean changed = mLastShowInputRequested != mShowInputRequested;
         if (mIsFullscreen != isFullscreen || !mFullscreenApplied) {
@@ -1014,6 +1016,25 @@ public class InputMethodService extends AbstractInputMethodService {
     }
 
     /**
+     * Splitview stuff - FIXME: This needs a proper doc entry
+     * @hide
+     */
+    public boolean onEvaluateSplitView() {
+        if (mCandidatesFrame.getChildCount() > 0) {
+            Context candidateContext = mCandidatesFrame.getChildAt(0).getContext();
+            if (candidateContext instanceof Activity) {
+                return ((Activity) candidateContext).isSplitView();
+            } else {
+                Log.e("XPLOD", "NOT ACTIVITY");
+                return false;
+            }
+        } else {
+            Log.e("XPLOD", "NO CHILD");
+            return false;
+        }
+    }
+
+    /**
      * Controls the visibility of the extracted text area.  This only applies
      * when the input method is in fullscreen mode, and thus showing extracted
      * text.  When false, the extracted text will not be shown, allowing some
diff --git a/core/java/android/view/IWindowManager.aidl b/core/java/android/view/IWindowManager.aidl
index c92a104..4edb6c3 100644
--- a/core/java/android/view/IWindowManager.aidl
+++ b/core/java/android/view/IWindowManager.aidl
@@ -282,4 +282,14 @@ interface IWindowManager
      * @param enabled Whether touch exploration is enabled.
      */
     void setTouchExplorationEnabled(boolean enabled);
+
+    /** SPLIT VIEW **/
+    boolean isTaskSplitView(int taskId);
+    void setTaskSplitView(int taskId, boolean split);
+    void setTaskChildSplit(int taskId, IBinder token, boolean split);
+    Rect getSplitViewRect(int taskId);
+    void notifyActivityTouched(IBinder token, boolean force);
+    void setSplitViewRect(int l, int t, int r, int b);
+
+    /** SPLIT VIEW END **/
 }
diff --git a/packages/SystemUI/res/menu/recent_popup_menu.xml b/packages/SystemUI/res/menu/recent_popup_menu.xml
index eecfb9a..f9de375 100644
--- a/packages/SystemUI/res/menu/recent_popup_menu.xml
+++ b/packages/SystemUI/res/menu/recent_popup_menu.xml
@@ -18,6 +18,7 @@
 */
 -->
 <menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:id="@+id/recent_add_split_view" android:title="@string/status_bar_recent_add_to_split_view" />
     <item android:id="@+id/recent_remove_item" android:title="@string/status_bar_recent_remove_item_title" />
     <item android:id="@+id/recent_inspect_item" android:title="@string/status_bar_recent_inspect_item_title" />
 </menu>
diff --git a/packages/SystemUI/res/values/custom_strings.xml b/packages/SystemUI/res/values/custom_strings.xml
index ebe5346..f7beaef 100644
--- a/packages/SystemUI/res/values/custom_strings.xml
+++ b/packages/SystemUI/res/values/custom_strings.xml
@@ -16,6 +16,9 @@
 
 -->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- Title shown in recents popup for adding an application to the split view -->
+    <string name="status_bar_recent_add_to_split_view">Put aside</string>
+
     <!-- Quick Settings Wi-Fi Back Tile Tethering label -->
     <string name="quick_settings_wifi_tethering_label">Tethering</string>
     <string name="quick_settings_wifi_tethering_off_label">Tethering Off</string>
diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
index 19f8d8e..9904663 100644
--- a/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
@@ -176,6 +176,13 @@ public class RecentsActivity extends Activity {
         finish();
     }
 
+    public void dismissAndDoNothing() {
+        if (mRecentsPanel != null) {
+            mRecentsPanel.show(false);
+        }
+        finish();
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         getWindow().addPrivateFlags(
diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
index 0c41cb0..75ff0c0 100644
--- a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
@@ -24,14 +24,18 @@ import android.app.ActivityManagerNative;
 import android.app.ActivityOptions;
 import android.app.TaskStackBuilder;
 import android.content.ActivityNotFoundException;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
+import android.graphics.Point;
 import android.graphics.Shader.TileMode;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
@@ -43,6 +47,8 @@ import android.provider.Settings;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.view.Gravity;
+import android.view.Display;
+import android.view.IWindowManager;
 import android.view.LayoutInflater;
 import android.view.MenuItem;
 import android.view.MotionEvent;
@@ -50,6 +56,8 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewPropertyAnimator;
 import android.view.ViewRootImpl;
+import android.view.WindowManager;
+import android.view.WindowManagerGlobal;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.animation.AnimationUtils;
 import android.view.animation.DecelerateInterpolator;
@@ -68,6 +76,7 @@ import com.android.systemui.statusbar.StatusBarPanel;
 import com.android.systemui.statusbar.phone.PhoneStatusBar;
 
 import java.util.ArrayList;
+import java.util.List;
 
 public class RecentsPanelView extends FrameLayout implements OnItemClickListener, RecentsCallback,
         StatusBarPanel, Animator.AnimatorListener {
@@ -97,6 +106,9 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
     private CircleMemoryMeter mRecentsMemoryIndicator;
     private boolean mUpdateMemoryIndicator;
 
+    private int mDragPositionX;
+    private int mDragPositionY;
+
     public static interface RecentsScrollView {
         public int numItemsInOneScreenful();
         public void setAdapter(TaskDescriptionAdapter adapter);
@@ -227,6 +239,12 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
 
             holder.thumbnailView.setTag(td);
             holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
+            holder.thumbnailView.setOnTouchListener(new OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent m) {
+                    return handleThumbnailTouch(m, holder.thumbnailView);
+                }
+            });
             holder.taskDescription = td;
             return convertView;
         }
@@ -430,6 +448,58 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         }
     }
 
+    private boolean handleThumbnailTouch(MotionEvent m, View thumb) {
+        // If we have two touches, let user snap on top or bottom
+        int pointerCount = m.getPointerCount();
+        if (pointerCount == 2) {
+            int action = m.getActionMasked();
+            int currX = (int) m.getX(1);
+            int currY = (int) m.getY(1);
+
+            switch (action) {
+                case MotionEvent.ACTION_DOWN:
+                case MotionEvent.ACTION_POINTER_DOWN:
+                    mDragPositionX = currX;
+                    mDragPositionY = currY;
+                    break;
+
+                case MotionEvent.ACTION_UP:
+                    handleThumbnailDragRelease(thumb);
+                    break;
+
+                case MotionEvent.ACTION_MOVE:
+                    int diffX = currX - mDragPositionX;
+                    int diffY = currY - mDragPositionY;
+                    thumb.setTranslationX(thumb.getTranslationX() + diffX);
+                    thumb.setTranslationY(thumb.getTranslationY() + diffY);
+                    mDragPositionX = currX;
+                    mDragPositionY = currY;
+                    break;
+            }
+
+            return true;
+        } else {
+            mDragPositionX = 0;
+            mDragPositionY = 0;
+            return false;
+        }
+    }
+
+    private void handleThumbnailDragRelease(View view) {
+        ViewHolder holder = (ViewHolder) view.getTag();
+        WindowManager wm = (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        Point size = new Point();
+        display.getSize(size);
+        int width = size.x;
+        int height = size.y;
+        if (mDragPositionY < height/2) {
+            openInSplitView(holder, 0);
+        } else {
+            openInSplitView(holder, 1);
+        }
+    }
+
     protected void onAttachedToWindow () {
         super.onAttachedToWindow();
         final ViewRootImpl root = getViewRootImpl();
@@ -454,6 +524,10 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         ((RecentsActivity) mContext).dismissAndGoBack();
     }
 
+    public void dismissAndDoNothing() {
+        ((RecentsActivity) mContext).dismissAndDoNothing();
+    }
+
     public void onAnimationCancel(Animator animation) {
     }
 
@@ -775,8 +849,19 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
                         holder.thumbnailViewImage, bm, 0, 0, null).toBundle();
 
         show(false);
+
         if (ad.taskId >= 0) {
             // This is an active task; it should just go to the foreground.
+            // If that task was split viewed, a normal press wil resume it to
+            // normal fullscreen view
+            IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            try {
+                if (DEBUG) Log.v(TAG, "Restoring window full screen after split, because of normal tap");
+                wm.setTaskSplitView(ad.taskId, false);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Could not setTaskSplitView to fullscreen", e);
+            }
+
             am.moveTaskToFront(ad.taskId, ActivityManager.MOVE_TASK_WITH_HOME,
                     opts);
         } else {
@@ -856,6 +941,95 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         }
     }
 
+    /**
+     * Opens the task linked in the ViewHolder in split view mode.
+     * @param holder ViewHolder of a task thumbnail
+     * @param location Where to put the split app (-1 for auto, 0 for top, 1 for bottom (the
+     * reference is a phone in portrait))
+     */
+    public void openInSplitView(ViewHolder holder, int location) {
+        if (holder != null) {
+            final Context context = holder.thumbnailView.getContext();
+            final ActivityManager am = (ActivityManager)
+                context.getSystemService(Context.ACTIVITY_SERVICE);
+            final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+
+            TaskDescription ad = holder.taskDescription;
+
+            show(false);
+            dismissAndDoNothing();
+
+            // If we weren't on the homescreen, resize the previous activity (if not already split)
+            final List<ActivityManager.RecentTaskInfo> recentTasks =
+                am.getRecentTasks(20, ActivityManager.RECENT_IGNORE_UNAVAILABLE);
+
+            if (recentTasks != null && recentTasks.size() > 0) {
+                final PackageManager pm = mContext.getPackageManager();
+                ActivityInfo homeInfo = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME)
+                        .resolveActivityInfo(pm, 0);
+                int taskInt = 0;
+                ActivityManager.RecentTaskInfo taskInfo = recentTasks.get(1);
+                Log.e("XPLOD", "Resizing previous activity " + taskInfo.baseIntent);
+                Intent intent = new Intent(taskInfo.baseIntent);
+                if (taskInfo.origActivity != null) {
+                    intent.setComponent(taskInfo.origActivity);
+                }
+
+                ComponentName component = intent.getComponent();
+
+                if (homeInfo == null
+                    || !homeInfo.packageName.equals(component.getPackageName())
+                    || !homeInfo.name.equals(component.getClassName())) {
+                    Log.e("XPLOD", "not home intent, splitting");
+                    // This is not the home activity, so split it
+                    try {
+                        wm.setTaskSplitView(taskInfo.persistentId, true);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Could not set previous task to split view", e);
+                    }
+
+                    // We move this to front first, then our activity, so it updates
+                    am.moveTaskToFront(taskInfo.persistentId, 0, null);
+                }
+            }
+
+            if (ad.taskId >= 0) {
+                // The task is already launched. The Activity will pull its split
+                // information from WindowManagerService once it resumes, so we
+                // set its state here.
+                try {
+                    wm.setTaskSplitView(ad.taskId, true);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Could not setTaskSplitView", e);
+                }
+                am.moveTaskToFront(ad.taskId, 0, null);
+            } else {
+                // The app has been killed (we have no taskId for it), so we start
+                // a new one with the SPLIT_VIEW flag
+                Intent intent = ad.intent;
+                intent.addFlags(Intent.FLAG_ACTIVITY_SPLIT_VIEW
+                    | Intent.FLAG_ACTIVITY_NEW_TASK);
+
+                if (DEBUG) Log.v(TAG, "Starting split view activity " + intent);
+
+                try {
+                    context.startActivityAsUser(intent, null,
+                            new UserHandle(UserHandle.USER_CURRENT));
+                } catch (SecurityException e) {
+                    Log.e(TAG, "Recents does not have the permission to launch " + intent, e);
+                }
+            }
+
+            try {
+                ActivityManagerNative.getDefault().notifySplitViewLayoutChanged();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Could not notify split view layout", e);
+            }
+        } else {
+            throw new IllegalStateException("Oops, no tag on view to split!");
+        }
+    }
+
     public void handleLongPress(
             final View selectedView, final View anchorView, final View thumbnailView) {
         thumbnailView.setSelected(true);
@@ -876,6 +1050,11 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
                     } else {
                         throw new IllegalStateException("Oops, no tag on view " + selectedView);
                     }
+                } else if (item.getItemId() == R.id.recent_add_split_view) {
+                    // Either start a new activity in split view, or move the current task
+                    // to front, but resized
+                    ViewHolder holder = (ViewHolder)selectedView.getTag();
+                    openInSplitView(holder, -1);
                 } else {
                     return false;
                 }
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindow.java b/policy/src/com/android/internal/policy/impl/PhoneWindow.java
index 38a8e06..947bdf1 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindow.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindow.java
@@ -39,6 +39,7 @@ import com.android.internal.widget.ActionBarContextView;
 import com.android.internal.widget.ActionBarOverlayLayout;
 import com.android.internal.widget.ActionBarView;
 
+import android.app.Activity;
 import android.app.KeyguardManager;
 import android.content.ComponentName;
 import android.content.ContentResolver;
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index e8530f7..b1b3153 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -3575,6 +3575,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
     }
 
+    public Rect getContentRect() {
+        return new Rect(mContentLeft, mContentTop, mContentRight, mContentBottom);
+    }
+
     /** {@inheritDoc} */
     @Override
     public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index 9201b1d..e09eadf 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -7253,6 +7253,24 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
     }
 
+    public IBinder getActivityForTask(int task, boolean onlyRoot) {
+        final ActivityStack mainStack = mStackSupervisor.getFocusedStack();
+        synchronized(this) {
+            ArrayList<ActivityStack> stacks = mStackSupervisor.getStacks();
+            for (ActivityStack stack : stacks) {
+                TaskRecord r = stack.taskForIdLocked(task);
+
+                if (r != null && r.getTopActivity() != null) {
+                    return r.getTopActivity().appToken;
+                } else {
+                    return null;
+                }
+            }
+        }
+        return null;
+    }
+
+
     // =========================================================
     // THUMBNAILS
     // =========================================================
@@ -14139,6 +14157,26 @@ public final class ActivityManagerService extends ActivityManagerNative
             // And we need to make sure at this point that all other activities
             // are made visible with the correct configuration.
             mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes);
+/*
+            if (mWindowManager.isTaskSplitView(starting.task.taskId)) {
+                Log.e("XPLOD", "Split view restoring task " + starting.task.taskId + " -- " + mIgnoreSplitViewUpdate.size());
+                ActivityRecord second = mainStack.topRunningActivityLocked(starting);
+                if (mWindowManager.isTaskSplitView(second.task.taskId)) {
+                    Log.e("XPLOD", "Split view restoring also task " + second.task.taskId);
+                    kept = kept && mainStack.ensureActivityConfigurationLocked(second, changes);
+                    mStackSupervisor.ensureActivitiesVisibleLocked(second, changes);
+                    if (mIgnoreSplitViewUpdate.contains(starting.task.taskId)) {
+                        Log.e("XPLOD", "Task "+ starting.task.taskId + " resuming ignored");
+                        mIgnoreSplitViewUpdate.removeAll(Collections.singleton((Integer) starting.task.taskId));
+                    } else {
+                        moveTaskToFront(second.task.taskId, 0, null);
+                        mIgnoreSplitViewUpdate.add(starting.task.taskId);
+                        mIgnoreSplitViewUpdate.add(second.task.taskId);
+                        mStackSupervisor.resumeTopActivitiesLocked();
+                        moveTaskToFront(starting.task.taskId, 0, null);
+                    }
+                }
+            }*/
         }
 
         if (values != null && mWindowManager != null) {
@@ -14148,6 +14186,8 @@ public final class ActivityManagerService extends ActivityManagerNative
         return kept;
     }
 
+private ArrayList<Integer> mIgnoreSplitViewUpdate = new ArrayList<Integer>();
+
     /**
      * Decide based on the configuration whether we should shouw the ANR,
      * crash, etc dialogs.  The idea is that if there is no affordnace to
@@ -15363,8 +15403,38 @@ public final class ActivityManagerService extends ActivityManagerNative
                 reportingProcessState, now);
     }
 
+    private ArrayList<Integer> mIgnoreSplitViewUpdateResume = new ArrayList<Integer>();
+
     private final ActivityRecord resumedAppLocked() {
-        return mStackSupervisor.resumedAppLocked();
+        final ActivityRecord starting = mStackSupervisor.resumedAppLocked();
+
+        if (mSplitResumeOrder != null && mSplitResumeOrder.size() > 0) {
+            final long origId = Binder.clearCallingIdentity();
+
+            int taskToResume = mSplitResumeOrder.get(0);
+            moveTaskToFront(taskToResume, 0, null);
+            mStackSupervisor.resumeTopActivitiesLocked();
+            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
+
+            mSplitResumeOrder.remove(0);
+
+            /*if (mSecondTaskToResume >= 0) {
+                moveTaskToFront(mSecondTaskToResume, 0, null);
+                mStackSupervisor.resumeTopActivitiesLocked();
+                mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
+                mIgnoreSplitViewUpdateResume.add(mSecondTaskToResume);
+
+                if (mIgnoreSplitViewUpdateResume.contains((Integer) starting.task.taskId)) {
+                    mSecondTaskToResume = -1;
+                } else {
+                    mSecondTaskToResume = starting.task.taskId;
+                }
+            }*/
+
+            Binder.restoreCallingIdentity(origId);
+        }
+
+        return starting;
     }
 
     final boolean updateOomAdjLocked(ProcessRecord app) {
@@ -16614,4 +16684,31 @@ public final class ActivityManagerService extends ActivityManagerNative
         info.applicationInfo = getAppInfoForUser(info.applicationInfo, userId);
         return info;
     }
+
+    private List<Integer> mSplitResumeOrder;
+
+    public void notifySplitViewLayoutChanged() {
+        final long origId = Binder.clearCallingIdentity();
+
+        Log.e("XPLOD/AMS", "notifySplitViewLayoutChanged");
+
+        if (mWindowManager != null) {
+            // We go through all activities and resume all those splitted, so that they
+            // can relayout properly considering we changed the split view layout.
+            mSplitResumeOrder = new ArrayList<Integer>(mWindowManager.getSplitTaskRenderOrder());
+            getFocusedStack().findTaskToMoveToFrontLocked(mSplitResumeOrder.get(0), 0, null);
+            mStackSupervisor.resumeTopActivitiesLocked();
+            mSplitResumeOrder.remove(0);
+
+            // see resumedAppLocked - we wait on each app to resume the next one
+            // xplodwild: THIS IS A GODDAMN HACK! With light apps it will be ok,
+            // but heavier apps will take a fuckin' huge amount of resources to resume.
+            // Ideally, we'd hook in Policy or WindowManager to manually move the windows
+            // without telling Activity/ActivityManager, THEN only resume the activities
+            // when they are indeed moved to front (that's why getSplitViewRect layouts already
+            // with the proper final size)
+        }
+
+        Binder.restoreCallingIdentity(origId);
+    }
 }
diff --git a/services/java/com/android/server/am/ActivityStack.java b/services/java/com/android/server/am/ActivityStack.java
index 0e15261..a5a279d 100644
--- a/services/java/com/android/server/am/ActivityStack.java
+++ b/services/java/com/android/server/am/ActivityStack.java
@@ -73,8 +73,11 @@ import android.os.SystemClock;
 import android.os.Trace;
 import android.os.UserHandle;
 import android.util.EventLog;
+import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
+import android.view.IWindowManager;
+import android.view.WindowManagerGlobal;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -1100,13 +1103,11 @@ final class ActivityStack {
                                 mStackSupervisor.startSpecificActivityLocked(r, false, false);
                             }
                         }
-
                     } else if (r.visible) {
                         // If this activity is already visible, then there is nothing
                         // else to do here.
                         if (DEBUG_VISBILITY) Slog.v(TAG, "Skipping: already visible at " + r);
                         r.stopFreezingScreenLocked(false);
-
                     } else if (onlyThisProcess == null) {
                         // This activity is not currently visible, but is running.
                         // Tell it to become visible.
@@ -1137,7 +1138,16 @@ final class ActivityStack {
                     // Aggregate current change flags.
                     configChanges |= r.configChangeFlags;
 
-                    if (r.fullscreen) {
+                    boolean isSplitView = false;
+
+                    try {
+                        IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+                        isSplitView = wm.isTaskSplitView(r.task.taskId);
+                    } catch (RemoteException e) {
+                        Slog.e(TAG, "Cannot get split view status", e);
+                    }
+
+                    if (r.fullscreen && !isSplitView) {
                         // At this point, nothing else needs to be shown
                         if (DEBUG_VISBILITY) Slog.v(TAG, "Fullscreen: at " + r);
                         behindFullscreen = true;
@@ -1244,6 +1254,7 @@ final class ActivityStack {
      * nothing happened.
      */
     final boolean resumeTopActivityLocked(ActivityRecord prev) {
+        Log.e("XPLOD", "Resume Top Activity Locked " + prev);
         return resumeTopActivityLocked(prev, null);
     }
 
diff --git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerService.java
index ef69382..55bd559 100644
--- a/services/java/com/android/server/wm/WindowManagerService.java
+++ b/services/java/com/android/server/wm/WindowManagerService.java
@@ -46,6 +46,7 @@ import com.android.server.power.ShutdownThread;
 
 import android.Manifest;
 import android.app.ActivityManager.StackBoxInfo;
+import android.app.ActivityManager;
 import android.app.ActivityManagerNative;
 import android.app.IActivityManager;
 import android.app.StatusBarManager;
@@ -151,6 +152,7 @@ import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.List;
 
 /** {@hide} */
@@ -797,6 +799,8 @@ public class WindowManagerService extends IWindowManager.Stub
         // Add ourself to the Watchdog monitors.
         Watchdog.getInstance().addMonitor(this);
 
+        setupSplitView();
+
         SurfaceControl.openTransaction();
         try {
             createWatermarkInTransaction();
@@ -9906,7 +9910,31 @@ public class WindowManagerService extends IWindowManager.Stub
 
             if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: Found new focus @ " + i +
                         " = " + win);
-            return win;
+
+            // Dispatch to this window if it is wants key events.
+            if (win.canReceiveKeys()) {
+                if (mFocusedApp != null) {
+                    SplitViewTaskInfo splitTaskInfo = getSplitInfo(mFocusedApp.token);
+
+                    if (splitTaskInfo != null && splitTaskInfo.taskType > SPLIT_TASK_FULLSCREEN) {
+                        if ((mTaskTouched != null && mTaskTouched.equals(mFocusedApp.token))
+                            || mTaskTouched == null) {
+                            if (DEBUG_FOCUS) Slog.v(
+                                TAG, "Found focus @ " + i + " = " + win);
+                            return win;
+                        } else {
+                            if (DEBUG_FOCUS || localLOGV) Slog.v(
+                                TAG, "Task " + win + " is split, but not last touched");
+                        }
+                    } else {
+                        if (DEBUG_FOCUS) Slog.v(TAG, "Task " + win + " has no split token");
+                        return win;
+                    }
+                } else {
+                    if (DEBUG_FOCUS) Slog.v(TAG, "Null thisApp");
+                    return win;
+                }
+            }
         }
 
         if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: No focusable windows.");
@@ -10903,4 +10931,528 @@ public class WindowManagerService extends IWindowManager.Stub
     public void addSystemUIVisibilityFlag(int flag) {
         mLastStatusBarVisibility |= flag;
     }
+
+    /** SPLIT VIEW **/
+
+    // Full-screen app
+    private final static int SPLIT_TASK_FULLSCREEN = -1;
+    // Main front app
+    private final static int SPLIT_TASK_MAIN = 0;
+    // Side front app
+    private final static int SPLIT_TASK_SIDE = 1;
+
+    // Folded card width in pixels
+    private final static int FOLDED_CARD_WIDTH = 30;
+    // Unfolded card width in pixels
+    private final static int UNFOLDED_CARD_WIDTH = 120;
+    // Unfold drift (overlap) in pixels
+    private final static int UNFOLDED_CARD_DRIFT = 40;
+
+    private int mSplitViewTasks[];
+    private SplitViewTaskInfo mMainTask;
+    private List<SplitViewTaskInfo> mSplitTaskStack;
+    private List<Integer> mSplitTaskRenderOrder;
+    private IBinder mTaskTouched;
+    private Rect mSplitViewRect = new Rect();
+
+    // true = cards are folded, false = cards are unfolded
+    private boolean mIsStackFolded;
+
+    public class SplitViewTaskInfo {
+        // The tokens of the windows of this split view task
+        public List<IBinder> tokens = new ArrayList<IBinder>();
+
+        // The task id of this split view task
+        public int taskId;
+
+        // One of SPLIT_TASK_...
+        public int taskType;
+    }
+
+    private void setupSplitView() {
+        mSplitViewTasks = new int[2];
+        mSplitTaskStack = new ArrayList<SplitViewTaskInfo>();
+        mSplitTaskRenderOrder = new ArrayList<Integer>();
+        mIsStackFolded = true;
+    }
+
+    public List<Integer> getSplitTaskRenderOrder() {
+        return mSplitTaskRenderOrder;
+    }
+
+    /**
+     * Returns a SplitViewTaskInfo for the provided token, or null if
+     * the token isn't in split view mode.
+     */
+    public SplitViewTaskInfo getSplitInfo(IBinder token) {
+        for (SplitViewTaskInfo taskInfo : mSplitTaskStack) {
+            if (taskInfo.tokens.contains(token)) {
+                return taskInfo;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns a SplitViewTaskInfo for the provided task id, or null if
+     * the task isn't in split view mode.
+     */
+    public SplitViewTaskInfo getSplitInfo(int taskId) {
+        for (SplitViewTaskInfo taskInfo : mSplitTaskStack) {
+            if (taskInfo.taskId == taskId) {
+                return taskInfo;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Prunes fullscreen activities from the split task stack,
+     * and make sure the main app and the front side app are at
+     * the top of the stack.
+     */
+    public void reorganizeSplitTaskStack() {
+        int index = 0;
+        for (SplitViewTaskInfo taskInfo : mSplitTaskStack) {
+            Log.e(TAG, "XPLOD/ Checking task id " + taskInfo.taskId);
+
+            if (taskInfo.taskType == SPLIT_TASK_FULLSCREEN) {
+                Log.e(TAG, "XPLOD/ ==> Task is FULLSCREEN, pruning!");
+                mSplitTaskStack.remove(index);
+                // Restart reorganization
+                reorganizeSplitTaskStack();
+                return;
+            }
+            else if (taskInfo.taskType == SPLIT_TASK_MAIN && index != 0) {
+                Log.e(TAG, "XPLOD/ ==> Task is TASK_MAIN and not at index 0!");
+                mSplitTaskStack.remove(index);
+                mSplitTaskStack.add(0, taskInfo);
+                // Restart reorganization
+                reorganizeSplitTaskStack();
+                return;
+            }
+
+            ++index;
+        }
+    }
+
+    public void wakeUpAndUpdateSplitTasks() {
+        Log.e(TAG, "XPLOD_TRACE/ Wake Up And Update Split Tasks (folded=" + mIsStackFolded + ")");
+
+        final long origId = Binder.clearCallingIdentity();
+
+        // Two rules here:
+        // - If we are in folded status, the main activity (task index 0 in our
+        //   stack) should be above everything, and the side stack rendered/awaken
+        //   from bottom to top.
+        // - When unfolded, apps on the side stack might (and will) overlap the main
+        //   activity, so it must be rendered first.
+        int lastIndexFor = 0;
+
+        mSplitTaskRenderOrder.clear();
+
+        if (!mIsStackFolded) {
+            lastIndexFor = 1;
+            //moveTaskAndActivityToFront(mSplitTaskStack.get(0).taskId);
+            mSplitTaskRenderOrder.add(mSplitTaskStack.get(0).taskId);
+
+            try {
+                IBinder token = mActivityManager.getActivityForTask(mSplitTaskStack.get(0).taskId, false);
+
+                WindowToken winToken = mTokenMap.get(token);
+
+                Log.e("XPLOD_TRACE", "There are " + winToken.windows.size() + " windows!");
+
+                for (WindowState state : winToken.windows) {
+                    WindowManager.LayoutParams lp = state.getAttrs();
+                    lp.x = 300;
+                    state.showLw(true, true);
+                }
+            } catch (RemoteException e) {
+                Log.e(TAG, "Cannot retrieve activity token for task " + mSplitTaskStack.get(0).taskId, e);
+            }
+        }
+
+        for (int i = mSplitTaskStack.size()-1; i >= lastIndexFor; i--) {
+            //moveTaskAndActivityToFront(mSplitTaskStack.get(i).taskId);
+            mSplitTaskRenderOrder.add(mSplitTaskStack.get(i).taskId);
+
+            try {
+                IBinder token = mActivityManager.getActivityForTask(mSplitTaskStack.get(i).taskId, false);
+
+                WindowToken winToken = mTokenMap.get(token);
+
+                Log.e("XPLOD_TRACE", "There are " + winToken.windows.size() + " windows!");
+
+                for (WindowState state : winToken.windows) {
+                    WindowManager.LayoutParams lp = state.getAttrs();
+                    lp.x = 300;
+                    state.showLw(true, true);
+                    state.mDisplayContent.layoutNeeded = true;
+                    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                        false /*updateInputWindows*/);
+                    performLayoutAndPlaceSurfacesLocked();
+                    if (state.mAppToken != null) {
+                        state.mAppToken.updateReportedVisibilityLocked();
+                    }
+                }
+            } catch (RemoteException e) {
+                Log.e(TAG, "Cannot retrieve activity token for task " + mSplitTaskStack.get(i).taskId, e);
+            }
+        }
+
+        notifyWindowsChanged();
+        //performLayoutAndPlaceSurfacesLocked();
+
+        /*try {
+            mActivityManager.notifySplitViewLayoutChanged();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Unable to notify split view layout changed", e);
+        }*/
+        
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    // see wakeUpAndUpdateSplitTasks
+    private void moveTaskAndActivityToFront(int taskId) {
+        try {
+            moveTaskToTop(taskId);
+            mActivityManager.moveTaskToFront(taskId, 0, null);
+            Log.e("XPLOD", "Moving activity " + taskId + " to front");
+        } catch (RemoteException e) {
+            Log.e(TAG, "Cannot move the activity to front", e);
+        }
+    }
+
+    /**
+     * Returns whether or not the provided taskId is the front
+     * task of the main or side stack
+     */
+    private boolean isSplitTaskFront(int taskId) {
+        // Check top task (if any)
+        if (mSplitTaskStack.size() == 0) return false;
+        SplitViewTaskInfo taskInfo = mSplitTaskStack.get(0);
+        if (taskInfo.taskId == taskId) return true;
+
+        // Check second task
+        if (mSplitTaskStack.size() == 1) return false;
+        taskInfo = mSplitTaskStack.get(1);
+        if (taskInfo.taskId == taskId) return true;
+
+        // The mSplitTaskStack variable is ordered:
+        // [Main Task] [Front Side Task] [Other Side Task]..
+        // so if the task isn't the first or second element of the list,
+        // then it's not a front task on the main or side stack.
+        return false;
+    }
+
+    /**
+     * Returns whether or not the provided token is the front
+     * task of the main or side stack
+     */
+    private boolean isSplitTaskFront(IBinder token) {
+        SplitViewTaskInfo taskInfo = getSplitInfo(token);
+        return isSplitTaskFront(taskInfo.taskId);
+    }
+
+    public void moveSideTaskToFront(IBinder token) {
+        int index = 0;
+        for (SplitViewTaskInfo taskInfo : mSplitTaskStack) {
+            if (taskInfo.tokens.contains(token)) {
+                mSplitTaskStack.remove(index);
+                mSplitTaskStack.add(1, taskInfo);
+                break;
+            }
+
+            ++index;
+        }
+    }
+
+    /**
+     * Returns whether or not the provided taskId is in split view mode
+     * or not. Remember that the taskId is shared between all activities
+     * of an app, thus children activities from the root one shares the
+     * same taskId.
+     *
+     * @param taskId The task id of the activity
+     * @return True if the task is in split view mode
+     */
+    public boolean isTaskSplitView(int taskId) {
+        SplitViewTaskInfo taskInfo = getSplitInfo(taskId);
+        return ((taskInfo != null) && (taskInfo.taskType > SPLIT_TASK_FULLSCREEN));
+    }
+
+    /**
+     * Sets whether or not a task should be in split view or not. The
+     * update only occurs when activities performs a resume or restart
+     * operation.
+     *
+     * @param taskId The task id of the activity
+     * @param split True to enable split mode, false otherwise
+     */
+    public void setTaskSplitView(int taskId, boolean split) {
+        SplitViewTaskInfo taskInfo = getSplitInfo(taskId);
+        if (taskInfo == null) {
+            taskInfo = new SplitViewTaskInfo();
+            taskInfo.taskId = taskId;
+            mSplitTaskStack.add(taskInfo);
+            mSplitTaskRenderOrder.add(taskId);
+            Log.e("XPLOD", "Task added: " + taskId + " in slot " + (mSplitTaskStack.size()-1));
+        }
+
+        if (split) {
+            if (mMainTask == null) {
+                // We have no main task yet, set this app as the main
+                mMainTask = taskInfo;
+                taskInfo.taskType = SPLIT_TASK_MAIN;
+            } else {
+                taskInfo.taskType = SPLIT_TASK_SIDE;
+            }
+        } else {
+            if (taskInfo.taskType == SPLIT_TASK_MAIN) {
+                mMainTask = null;
+            }
+            taskInfo.taskType = SPLIT_TASK_FULLSCREEN;
+        }
+
+        try {
+            IBinder token = mActivityManager.getActivityForTask(taskId, false);
+            if (!taskInfo.tokens.contains(token)) {
+                taskInfo.tokens.add(token);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Cannot retrieve activity token for task " + taskId, e);
+        }
+
+        wakeUpAndUpdateSplitTasks();
+    }
+
+    /**
+     * Notifies the WindowManager that the provided token is split
+     * or not. This is useful because children activities don't share
+     * the same token, so Activity can notify the window token is split
+     * as well based on the taskId it reads during performRestart.
+     *
+     * @param token The activity token
+     * @param split True if the token should be split
+     */
+    public void setTaskChildSplit(int taskId, IBinder token, boolean split) {
+        SplitViewTaskInfo taskInfo = getSplitInfo(taskId);
+
+        if (taskInfo != null) {
+            if (!taskInfo.tokens.contains(token)) {
+                taskInfo.tokens.add(token);
+            }
+
+            if (!split) {
+                taskInfo.taskType = SPLIT_TASK_FULLSCREEN;
+            } else if (taskInfo == mMainTask) {
+                taskInfo.taskType = SPLIT_TASK_MAIN;
+            } else {
+                taskInfo.taskType = SPLIT_TASK_SIDE;
+            }
+        } else {
+            Log.e(TAG, "XPLOD_EARLY/ Cannot find taskInfo for task " + taskId + " that reported a new activity token");
+        }
+    }
+
+    /**
+     * Notifies that the provided activity token has been touched, and
+     * sets the focus to that activity, and move it to the front so it
+     * gets updated properly.
+     *
+     * @param token The activity token
+     * @param force Set this to true to force the focus update even if the
+     *              application was already focused
+     */
+    public void notifyActivityTouched(IBinder token, boolean force) {
+        if (!isSplitTaskFront(token)) {
+            Log.e(TAG, "XPLOD_TRACE/ notifyActivityTouched: Touched a non-front split task");
+            if (mIsStackFolded) {
+                // Side stack was folded, unfold it as we touched a back activity
+                Log.e(TAG, "XPLOD_TRACE/ notifyActivityTouched: Set folding status to FALSE");
+                mIsStackFolded = false;
+                // Update views/windows
+                wakeUpAndUpdateSplitTasks();
+            } else {
+                // Side stack was unfolded and we touched a non-front activity, put it to front
+                // and fold it back
+                Log.e(TAG, "XPLOD_TRACE/ notifyActivityTouched: Set folding status to TRUE and moving touched window to front!");
+                moveSideTaskToFront(token);
+                mIsStackFolded = true;
+                // Update views/windows
+                wakeUpAndUpdateSplitTasks();
+            }
+        } else {
+            mTaskTouched = token;
+            synchronized(mWindowMap) {
+                boolean changed = false;
+                if (token != null) {
+                    AppWindowToken newFocus = findAppWindowToken(token);
+                    if (newFocus == null) {
+                        Slog.w(TAG, "Attempted to set focus to non-existing app token: " + token);
+                        return;
+                    }
+                    changed = mFocusedApp != newFocus;
+                    mFocusedApp = newFocus;
+                    if (changed || force) {
+                        if (DEBUG_FOCUS) Slog.v(TAG, "Changed app focus to " + token);
+                        mInputMonitor.setFocusedAppLw(newFocus);
+                    }
+                }
+
+                if (changed || force) {
+                    final long origId = Binder.clearCallingIdentity();
+                    updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true);
+                    mH.removeMessages(H.REPORT_FOCUS_CHANGE);
+                    mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
+                    Binder.restoreCallingIdentity(origId);
+                }
+            }
+
+            // We only move the activity to front if it's not already the focused app.
+            // Not doing so causes a huge lag when opening an app in split view, because
+            // it is moved to front while starting.
+            if (!force) {
+                final long origId = Binder.clearCallingIdentity();
+                try {
+                    mActivityManager.moveTaskToFront(mActivityManager.getTaskForActivity(token, false), 0, null);
+                    //Log.e("XPLOD", "Moved activity to front because TOUCH!");
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Cannot move the activity to front", e);
+                }
+                Binder.restoreCallingIdentity(origId);
+            }
+        }
+    }
+
+    public void setSplitViewRect(int l, int t, int r, int b) {
+        Log.e("XPLOD", "Set split view rect ("+l+","+t+","+r+","+b+")");
+        mSplitViewRect.left = l;
+        mSplitViewRect.top = t;
+        mSplitViewRect.right = r;
+        mSplitViewRect.bottom = b;
+    }
+
+    /**
+     * Computes and return the final window metrics for the provided
+     * taskId.
+     * If the task isn't split, the full screen size is returned.
+     *
+     * @param taskId The id of the task
+     * @return A rect of the final window metrics
+     */
+    public Rect getSplitViewRect(int taskId) {
+        Log.e("XPLOD", "Debug Activity " + taskId + " asked for split view rect");
+
+        // TODO: Move me only when it matters
+        reorganizeSplitTaskStack();
+
+        // TODO(multidisplay): For now, apply Configuration to main screen only.
+        final DisplayContent displayContent = getDefaultDisplayContentLocked();
+
+        // Use the effective "visual" dimensions based on current rotation
+        final boolean rotated = (mRotation == Surface.ROTATION_90
+                || mRotation == Surface.ROTATION_270);
+        final int realdw = rotated ?
+                displayContent.mBaseDisplayHeight : displayContent.mBaseDisplayWidth;
+        final int realdh = rotated ?
+                displayContent.mBaseDisplayWidth : displayContent.mBaseDisplayHeight;
+        final boolean nativeLandscape =
+                (displayContent.mBaseDisplayHeight < displayContent.mBaseDisplayWidth);
+
+        int dw = realdw;
+        int dh = realdh;
+
+        // Get application display metrics.
+        int appWidth = mPolicy.getNonDecorDisplayWidth(dw, dh, mRotation);
+        int appHeight = mPolicy.getNonDecorDisplayHeight(dw, dh, mRotation);
+
+        SplitViewTaskInfo taskInfo = getSplitInfo(taskId);
+
+        if (taskInfo == null) {
+            Log.e(TAG, "XPLOD_EARLY/ Getting split view rect for task " + taskId + " but I have no idea what this app is! Returning fullscreen");
+            return new Rect(0, 0, appWidth, appHeight);
+        }
+
+
+        /** XPLOD TODO:
+         **  - Leave some room for folded/unfolded activities
+         **  - Detect tap on folded part of the screen
+         **  - Unfold on tap (animations + move ALL activities(!))
+         **/
+
+        // Current positionning policy: main task has 50% of the screen,
+        // side apps have 50% minus the space needed for folded apps.
+        // In case apps are unfolded, apps back in the side stack might
+        // overlap/drift above the main (left) app.
+        // Please note that all calculations are done with a LANDSCAPE
+        // viewport, so we have apps on left and right (not top and bottom).
+        // Rotation is done afterwards when returning the Rect
+        if (taskInfo.taskType == SPLIT_TASK_MAIN) {
+            if (nativeLandscape ^ rotated) {
+                return new Rect(0, 0, appWidth/2, appHeight);
+            } else {
+                return new Rect(0, 0, appWidth, appHeight/2);
+            }
+        } else if (taskInfo.taskType == SPLIT_TASK_SIDE) {
+            int driftRight = 0, driftLeft = 0;
+
+            // Drift cards
+            // TODO: Simplify this logic
+            if (mIsStackFolded) {
+                if (isSplitTaskFront(taskInfo.taskId)) {
+                    // We compute the total size of the back stack depth (minus this
+                    // front activity) so that, according to the positionning policy,
+                    // we shift the right stack and leave 50% to the main app at all time
+
+                    // From here, we are on the side, so we assume we have at least 2 tasks in
+                    // the stack.
+                    if (mSplitTaskStack.size() < 2) {
+                        throw new RuntimeException("We're positionning the side app, but we have less than 2 apps in the stack!");
+                    }
+                    int totalBackDepth = mSplitTaskStack.size() - 2;
+                    driftLeft = FOLDED_CARD_WIDTH * totalBackDepth;
+
+                    Log.e(TAG, "XPLOD_LAYOUT/ Layouting front side task " + taskInfo.taskId + " with " + driftLeft + "/" + driftRight + " drift");
+                } else {
+                    int cardDepth = mSplitTaskStack.indexOf(taskInfo) - 1;
+                    driftRight = -FOLDED_CARD_WIDTH * cardDepth;
+
+                    Log.e(TAG, "XPLOD_LAYOUT/ Layouting back side task " + taskInfo.taskId + " with " + driftLeft + "/" + driftRight + " drift");
+                }
+            } else {
+                // When cards are unfolded, we overlap on the main (left) app/card
+                if (isSplitTaskFront(taskInfo.taskId)) {
+                    if (mSplitTaskStack.size() < 2) {
+                        throw new RuntimeException("We're positionning the side app, but we have less than 2 apps in the stack!");
+                    }
+                    int totalBackDepth = mSplitTaskStack.size() - 2;
+                    driftLeft = FOLDED_CARD_WIDTH * totalBackDepth;
+
+                    Log.e(TAG, "XPLOD_LAYOUT/ Layouting front side task " + taskInfo.taskId + " with " + driftLeft + "/" + driftRight + " drift");
+                } else {
+                    int cardDepth = mSplitTaskStack.indexOf(taskInfo) - 1;
+                    driftRight = -UNFOLDED_CARD_WIDTH/2 * cardDepth;
+                    driftLeft = -UNFOLDED_CARD_WIDTH/2 * cardDepth;
+
+                    Log.e(TAG, "XPLOD_LAYOUT/ Layouting back side task " + taskInfo.taskId + " with " + driftLeft + "/" + driftRight + " drift");
+                }
+            }
+
+            if (nativeLandscape ^ rotated) {
+                return new Rect(appWidth/2 + driftLeft, 0, appWidth + driftRight, appHeight);
+            } else {
+                return new Rect(0, appHeight/2 + driftLeft, appWidth, appHeight + driftRight);
+            }
+        } else {
+            Log.e(TAG, "XPLOD_EARLY/ Getting split view rect for task " + taskId + " but it's not split main or side! (" + taskInfo.taskType + ") Returning fullscreen");
+            return new Rect(0, 0, appWidth, appHeight);
+        }
+
+    }
+
+    /** END SPLIT VIEW **/
 }
-- 
1.9.1

